// Code generated by re2c 2.2 on Fri Jun 14 19:15:48 2024, DO NOT EDIT.
package lexer

import (
    "bytes"
    "github.com/masp/awktree/token"
	"fmt"
)

func (l *Lexer) lex() (pos token.Pos, tok token.Type, lit string, err error) {
    for {
		lit = ""
		pos = l.pos()
		l.token = l.cursor


{
	var yych byte
	yyaccept := 0
	yych = l.input[l.cursor]
	if (yych <= '.') {
		if (yych <= '"') {
			if (yych <= '\f') {
				if (yych <= 0x08) {
					if (yych >= 0x01) {
						goto yy4
					}
				} else {
					if (yych <= '\t') {
						goto yy6
					}
					if (yych <= '\n') {
						goto yy9
					}
					goto yy4
				}
			} else {
				if (yych <= 0x1F) {
					if (yych <= '\r') {
						goto yy11
					}
					goto yy4
				} else {
					if (yych <= ' ') {
						goto yy6
					}
					if (yych <= '!') {
						goto yy12
					}
					goto yy13
				}
			}
		} else {
			if (yych <= ')') {
				if (yych <= '$') {
					if (yych <= '#') {
						goto yy4
					}
					goto yy15
				} else {
					if (yych <= '\'') {
						goto yy4
					}
					if (yych <= '(') {
						goto yy18
					}
					goto yy20
				}
			} else {
				if (yych <= '+') {
					if (yych <= '*') {
						goto yy22
					}
					goto yy24
				} else {
					if (yych <= ',') {
						goto yy26
					}
					if (yych <= '-') {
						goto yy28
					}
					goto yy30
				}
			}
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= ';') {
				if (yych <= '0') {
					if (yych <= '/') {
						goto yy32
					}
					goto yy34
				} else {
					if (yych <= '9') {
						goto yy36
					}
					if (yych <= ':') {
						goto yy38
					}
					goto yy40
				}
			} else {
				if (yych <= '=') {
					if (yych <= '<') {
						goto yy42
					}
					goto yy44
				} else {
					if (yych <= '>') {
						goto yy45
					}
					if (yych <= '?') {
						goto yy4
					}
					goto yy15
				}
			}
		} else {
			if (yych <= '_') {
				if (yych <= '\\') {
					if (yych <= '[') {
						goto yy47
					}
					goto yy4
				} else {
					if (yych <= ']') {
						goto yy49
					}
					if (yych <= '^') {
						goto yy4
					}
					goto yy15
				}
			} else {
				if (yych <= '{') {
					if (yych <= '`') {
						goto yy51
					}
					if (yych <= 'z') {
						goto yy15
					}
					goto yy53
				} else {
					if (yych == '}') {
						goto yy55
					}
					goto yy4
				}
			}
		}
	}
	l.cursor += 1
	{ tok = token.EOF; return }
yy4:
	l.cursor += 1
yy5:
	{ err = fmt.Errorf("%w: %c", ErrUnrecognizedToken, l.token); return }
yy6:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\t') {
		goto yy6
	}
	if (yych == ' ') {
		goto yy6
	}
	{
			continue
		}
yy9:
	l.cursor += 1
	{
			if l.insertSemi() {
				l.cursor = l.token // Has the effect of "inserting" the semicolon in the input
				tok = token.SEMICOLON
				lit = "\n"
				return
			} else {
				l.file.AddLine(l.token)
				continue
			}
		}
yy11:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\n') {
		goto yy9
	}
	goto yy5
yy12:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy57
	}
	goto yy5
yy13:
	l.cursor += 1
	{ return l.lexString('"') }
yy15:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '@') {
		if (yych <= '-') {
			if (yych >= '-') {
				goto yy15
			}
		} else {
			if (yych <= '/') {
				goto yy17
			}
			if (yych <= '9') {
				goto yy15
			}
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Z') {
				goto yy15
			}
			if (yych >= '_') {
				goto yy15
			}
		} else {
			if (yych <= '`') {
				goto yy17
			}
			if (yych <= 'z') {
				goto yy15
			}
		}
	}
yy17:
	{ tok = token.IDENT; lit = l.literal(); return }
yy18:
	l.cursor += 1
	{ tok = token.LPAREN; lit = "("; return }
yy20:
	l.cursor += 1
	{ tok = token.RPAREN; lit = ")"; return }
yy22:
	l.cursor += 1
	{ tok = token.STAR; lit = "*"; return }
yy24:
	l.cursor += 1
	{ tok = token.PLUS; lit = "+"; return }
yy26:
	l.cursor += 1
	{ tok = token.COMMA; lit = ","; return }
yy28:
	l.cursor += 1
	{ tok = token.MINUS; lit = "-"; return }
yy30:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '/') {
		goto yy31
	}
	if (yych <= '9') {
		goto yy59
	}
yy31:
	{ tok = token.PERIOD; lit = "."; return }
yy32:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '*') {
		goto yy62
	}
	if (yych == '/') {
		goto yy64
	}
	{ tok = token.SLASH; lit = "/"; return }
yy34:
	yyaccept = 0
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= '9') {
		if (yych == '.') {
			goto yy59
		}
		if (yych >= '0') {
			goto yy67
		}
	} else {
		if (yych <= 'E') {
			if (yych >= 'E') {
				goto yy70
			}
		} else {
			if (yych == 'e') {
				goto yy70
			}
		}
	}
yy35:
	{ tok = token.INT; lit = l.literal(); return }
yy36:
	yyaccept = 0
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= '9') {
		if (yych == '.') {
			goto yy59
		}
		if (yych <= '/') {
			goto yy35
		}
		goto yy36
	} else {
		if (yych <= 'E') {
			if (yych <= 'D') {
				goto yy35
			}
			goto yy70
		} else {
			if (yych == 'e') {
				goto yy70
			}
			goto yy35
		}
	}
yy38:
	l.cursor += 1
	{ tok = token.COLON; lit = ":"; return }
yy40:
	l.cursor += 1
	{ tok = token.SEMICOLON; lit = ";"; return }
yy42:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy71
	}
	{ tok = token.LESS; lit = "<"; return }
yy44:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy73
	}
	goto yy5
yy45:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '=') {
		goto yy75
	}
	{ tok = token.GREATER; lit = ">"; return }
yy47:
	l.cursor += 1
	{ tok = token.LSQUARE_BRACKET; lit = "["; return }
yy49:
	l.cursor += 1
	{ tok = token.RSQUARE_BRACKET; lit = "]"; return }
yy51:
	l.cursor += 1
	{ return l.lexPattern('`') }
yy53:
	l.cursor += 1
	{ tok = token.LCURLY_BRACKET; lit = "{"; return }
yy55:
	l.cursor += 1
	{ tok = token.RCURLY_BRACKET; lit = "}"; return }
yy57:
	l.cursor += 1
	{ tok = token.EQUAL_EQUAL; lit = "!="; return }
yy59:
	yyaccept = 1
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= 'D') {
		if (yych <= '/') {
			goto yy61
		}
		if (yych <= '9') {
			goto yy59
		}
	} else {
		if (yych <= 'E') {
			goto yy70
		}
		if (yych == 'e') {
			goto yy70
		}
	}
yy61:
	{ tok = token.FLOAT; lit = l.literal(); return }
yy62:
	yyaccept = 2
	l.cursor += 1
	l.marker = l.cursor
	yych = l.input[l.cursor]
	if (yych >= 0x01) {
		goto yy78
	}
yy63:
	{ return l.lexMultiComment() }
yy64:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy66
		}
		if (yych <= '\t') {
			goto yy64
		}
	} else {
		if (yych != '\r') {
			goto yy64
		}
	}
yy66:
	{ tok = token.COMMENT; lit = l.literal(); return }
yy67:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '9') {
		if (yych == '.') {
			goto yy59
		}
		if (yych >= '0') {
			goto yy67
		}
	} else {
		if (yych <= 'E') {
			if (yych >= 'E') {
				goto yy70
			}
		} else {
			if (yych == 'e') {
				goto yy70
			}
		}
	}
yy69:
	l.cursor = l.marker
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy35
		} else {
			goto yy61
		}
	} else {
		goto yy63
	}
yy70:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= ',') {
		if (yych == '+') {
			goto yy80
		}
		goto yy69
	} else {
		if (yych <= '-') {
			goto yy80
		}
		if (yych <= '/') {
			goto yy69
		}
		if (yych <= '9') {
			goto yy81
		}
		goto yy69
	}
yy71:
	l.cursor += 1
	{ tok = token.LESS_EQUAL; lit = "<="; return }
yy73:
	l.cursor += 1
	{ tok = token.EQUAL_EQUAL; lit = "=="; return }
yy75:
	l.cursor += 1
	{ tok = token.GREATER_EQUAL; lit = ">="; return }
yy77:
	l.cursor += 1
	yych = l.input[l.cursor]
yy78:
	if (yych <= 0x00) {
		goto yy69
	}
	if (yych != '*') {
		goto yy77
	}
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '/') {
		goto yy83
	}
	goto yy77
yy80:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '/') {
		goto yy69
	}
	if (yych >= ':') {
		goto yy69
	}
yy81:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '/') {
		goto yy61
	}
	if (yych <= '9') {
		goto yy81
	}
	goto yy61
yy83:
	l.cursor += 1
	{ tok = token.COMMENT; lit = l.literal(); return }
}

    }
}

func (l *Lexer) lexString(quote byte) (pos token.Pos, tok token.Type, lit string, err error) {
	var buf bytes.Buffer
	buf.WriteByte(quote)
	for {
		var u byte

{
	var yych byte
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy87
		}
		if (yych <= '\t') {
			goto yy89
		}
		goto yy91
	} else {
		if (yych == '\\') {
			goto yy93
		}
		goto yy89
	}
yy87:
	l.cursor += 1
	{
			err = ErrUnterminatedString
			tok = token.EOF
            pos = l.file.Pos(l.token)
			return
		}
yy89:
	l.cursor += 1
	{
			u = yych
			buf.WriteByte(u)
			if u == quote {
				tok = token.STRING
				pos = l.file.Pos(l.token)
				lit = string(buf.Bytes())
				return
			}
			continue
		}
yy91:
	l.cursor += 1
yy92:
	{ err = ErrInvalidString; return }
yy93:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'b') {
		if (yych <= '>') {
			if (yych <= '"') {
				if (yych <= '!') {
					goto yy92
				}
			} else {
				if (yych == '\'') {
					goto yy96
				}
				goto yy92
			}
		} else {
			if (yych <= '\\') {
				if (yych <= '?') {
					goto yy98
				}
				if (yych <= '[') {
					goto yy92
				}
				goto yy100
			} else {
				if (yych <= '`') {
					goto yy92
				}
				if (yych <= 'a') {
					goto yy102
				}
				goto yy104
			}
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'f') {
				if (yych <= 'e') {
					goto yy92
				}
				goto yy106
			} else {
				if (yych == 'n') {
					goto yy108
				}
				goto yy92
			}
		} else {
			if (yych <= 't') {
				if (yych <= 'r') {
					goto yy110
				}
				if (yych <= 's') {
					goto yy92
				}
				goto yy112
			} else {
				if (yych == 'v') {
					goto yy114
				}
				goto yy92
			}
		}
	}
	l.cursor += 1
	{ buf.WriteByte('"'); continue }
yy96:
	l.cursor += 1
	{ buf.WriteByte('\''); continue }
yy98:
	l.cursor += 1
	{ buf.WriteByte('?'); continue }
yy100:
	l.cursor += 1
	{ buf.WriteByte('\\'); continue }
yy102:
	l.cursor += 1
	{ buf.WriteByte('\a'); continue }
yy104:
	l.cursor += 1
	{ buf.WriteByte('\b'); continue }
yy106:
	l.cursor += 1
	{ buf.WriteByte('\f'); continue }
yy108:
	l.cursor += 1
	{ buf.WriteByte('\n'); continue }
yy110:
	l.cursor += 1
	{ buf.WriteByte('\r'); continue }
yy112:
	l.cursor += 1
	{ buf.WriteByte('\t'); continue }
yy114:
	l.cursor += 1
	{ buf.WriteByte('\v'); continue }
}
		
	}
}

func (l *Lexer) lexPattern(quote byte) (pos token.Pos, tok token.Type, lit string, err error) {
	for {

{
	var yych byte
	yych = l.input[l.cursor]
	if (yych >= 0x01) {
		goto yy120
	}
	l.cursor += 1
	{
			err = ErrUnterminatedString
			tok = token.EOF
            pos = l.file.Pos(l.token)
			return
		}
yy120:
	l.cursor += 1
	{
			if yych == quote {
				tok = token.PATTERN
				pos = l.file.Pos(l.token)
				lit = string(l.input[l.token:l.cursor])
				return
			}
			continue
		}
}
		
	}
}

func (l *Lexer) lexMultiComment() (pos token.Pos, tok token.Type, lit string, err error) {
	for {

{
	var yych byte
	yych = l.input[l.cursor]
	if (yych <= 0x00) {
		goto yy124
	}
	if (yych == '*') {
		goto yy128
	}
	goto yy126
yy124:
	l.cursor += 1
	{
			err = ErrUnterminatedComment
			tok = token.EOF
            pos = l.file.Pos(l.token)
			return
		}
yy126:
	l.cursor += 1
yy127:
	{ continue }
yy128:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych != '/') {
		goto yy127
	}
	l.cursor += 1
	{
			tok = token.COMMENT
			pos = l.file.Pos(l.token)
			lit = string(l.input[l.token+2:l.cursor])
			return
		}
}
		
	}
}